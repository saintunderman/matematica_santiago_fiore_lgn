<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Visualizador Interactivo de la Ley de los Grandes N칰meros</title>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <!-- MathJax -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet"/>

    <style>
        :root{
            --bg-color: #f8f9fa;
            --surface-color: #ffffff;
            --text-color: #212529;
            --text-muted-color: #6c757d;
            --border-color: #dee2e6;
            --info-bg-color: #e9f3ff;

            --expected-value-color: #dc3545;
            --chart-color-1: #0d6efd;
            --chart-color-2: #198754;
            --chart-color-3: #6f42c1;
            --chart-color-4: #fd7e14;
        }
        html{ scroll-behavior: smooth; }
        body{
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.7;
            padding: 2rem;
            font-size: 16px;
        }
        .container{ max-width: 1400px; margin: 0 auto; }
        header{ text-align: center; margin-bottom: 2rem; }
        header h1{ font-size: 2.4rem; font-weight: 700; color: var(--chart-color-1); }
        header p{ max-width: 800px; margin: .5rem auto 0; color: var(--text-muted-color); }

        .theory-box{
            background-color: var(--info-bg-color);
            border-left: 5px solid var(--chart-color-1);
            border-radius: 8px;
            padding: 1.5rem 2rem;
            margin: 0 auto 3rem auto;
            max-width: 950px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .controls-panel{
            background-color: var(--surface-color);
            padding: 1.2rem 1.4rem;
            border-radius: 12px;
            margin-bottom: 2.5rem;
            display:flex;
            flex-wrap:wrap;
            gap:1.25rem;
            align-items:center;
            justify-content:center;
            border:1px solid var(--border-color);
            box-shadow:0 4px 18px rgba(0,0,0,0.06);
        }
        .control-group{ display:flex; align-items:center; gap:.75rem; }
        .control-group label{ font-weight:500; color:var(--text-color); }
        input[type="number"]{ width:150px; padding:.5rem; border:2px solid var(--border-color); border-radius:6px; font-size:1rem; font-weight:600; color:var(--chart-color-1); text-align:center; }
        input[type="number"]:focus{ outline:none; border-color:var(--chart-color-1); }

        #simulateBtn{
            padding:.7rem 1.4rem; font-weight:700; color:#fff; background-color:var(--chart-color-1);
            border:none; border-radius:8px; cursor:pointer;
        }
        #simulateBtn[disabled]{ background-color:#6c757d; cursor:not-allowed; }

        .spinner{ width:16px; height:16px; border:2px solid rgba(255,255,255,0.3); border-top-color:#fff; border-radius:50%; animation:spin 1s linear infinite; display:inline-block; vertical-align:middle; }
        @keyframes spin{ to{ transform:rotate(360deg); } }

        .experiment-selector{ display:flex; flex-wrap:wrap; gap:1rem; justify-content:center; margin-bottom:2.5rem; }
        .experiment-btn{ padding:.8rem 1.5rem; font-weight:600; color:var(--text-color); background-color:var(--surface-color); border:2px solid var(--border-color); border-radius:8px; cursor:pointer; transition:all 0.2s ease; box-shadow:0 2px 8px rgba(0,0,0,0.06); }
        .experiment-btn:hover{ transform:translateY(-2px); box-shadow:0 4px 12px rgba(0,0,0,0.12); }
        .experiment-btn.active{ border-color:var(--chart-color-1); background-color:var(--chart-color-1); color:#fff; }

        .experiments-grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); gap:1.6rem; }

        .card{ background:var(--surface-color); border-radius:12px; padding:1rem; border:1px solid var(--border-color); box-shadow:0 6px 20px rgba(0,0,0,0.06); display:flex; flex-direction:column; min-height:360px; }
        .card.hidden{ display:none; }
        .card-header h2{ margin:0 0 .4rem 0; }
        .card-header .description{ color:var(--text-muted-color); margin-bottom:.6rem; }
        .chart-container{ position:relative; flex-grow:1; min-height:260px; }
        .final-average{ text-align:center; margin-top:1rem; padding-top:1rem; border-top:1px dashed var(--border-color); font-size:1.05rem; }
        .final-average span{ font-weight:700; }
        footer{ text-align:center; margin-top:2.5rem; padding-top:1.5rem; border-top:1px solid var(--border-color); color:var(--text-muted-color); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Visualizador Interactivo de la Ley de los Grandes N칰meros (LGN)</h1>
            <p>Una herramienta para explorar c칩mo los promedios de experimentos aleatorios convergen a sus valores esperados.</p>
        </header>

        <section class="theory-box" aria-label="Teor칤a">
            <p>La <strong>Ley de los Grandes N칰meros (LGN)</strong> establece que al aumentar el tama침o de la muestra, el promedio de los resultados observados converge al valor esperado te칩rico. Este es uno de los teoremas fundamentales de la probabilidad y estad칤stica, demostrando que las observaciones emp칤ricas se acercan a la teor칤a con suficientes repeticiones.</p>
        </section>

        <section class="controls-panel" aria-label="Controles">
            <div class="control-group">
                <label for="numTrials">N칰mero de Simulaciones:</label>
                <input type="number" id="numTrials" min="10" max="100000" step="100" value="2000" />
            </div>

            <div class="control-group">
                <input type="checkbox" id="toggleExpected" checked />
                <label for="toggleExpected">Mostrar Valor Esperado</label>
            </div>

            <div class="control-group">
                <button id="simulateBtn" type="button">Lanzar Simulaci칩n</button>
            </div>
        </section>

        <section class="experiment-selector" aria-label="Seleccionar Experimento">
            <button class="experiment-btn active" data-experiment="coin" type="button">游뿣 Lanzamiento de Moneda</button>
            <button class="experiment-btn" data-experiment="dice" type="button">游 Dado (6 caras)</button>
            <button class="experiment-btn" data-experiment="uniform" type="button">游늵 Distribuci칩n Uniforme</button>
            <button class="experiment-btn" data-experiment="bernoulli" type="button">游꿢 Ensayo de Bernoulli</button>
        </section>

        <section class="experiments-grid" aria-label="Experimentos">
            <!-- Coin -->
            <article class="card" data-experiment="coin">
                <div class="card-header">
                    <h2 style="color:var(--chart-color-1);">1. Lanzamiento de Moneda</h2>
                    <p class="description">Moneda justa (1 = cara, 0 = cruz).</p>
                    <p class="expected-value">Valor esperado: \(E[X]=0.5\)</p>
                </div>
                <div class="chart-container"><canvas id="coinChart" role="img" aria-label="Gr치fico moneda"></canvas></div>
                <div class="final-average" id="coinFinalAvg" aria-live="polite"></div>
            </article>

            <!-- Dice -->
            <article class="card hidden" data-experiment="dice">
                <div class="card-header">
                    <h2 style="color:var(--chart-color-2);">2. Lanzamiento de Dado (6 caras)</h2>
                    <p class="description">Dado justo 1..6. Promedio converge a 3.5.</p>
                    <p class="expected-value">Valor esperado: \(E[X]=3.5\)</p>
                </div>
                <div class="chart-container"><canvas id="diceChart" role="img" aria-label="Gr치fico dado"></canvas></div>
                <div class="final-average" id="diceFinalAvg" aria-live="polite"></div>
            </article>

            <!-- Uniform -->
            <article class="card hidden" data-experiment="uniform">
                <div class="card-header">
                    <h2 style="color:var(--chart-color-3);">3. Distribuci칩n Uniforme [0,1]</h2>
                    <p class="description">N칰meros uniformes; promedio tiende a 0.5.</p>
                    <p class="expected-value">Valor esperado: \(E[X]=0.5\)</p>
                </div>
                <div class="chart-container"><canvas id="uniformChart" role="img" aria-label="Gr치fico uniforme"></canvas></div>
                <div class="final-average" id="uniformFinalAvg" aria-live="polite"></div>
            </article>

            <!-- Bernoulli -->
            <article class="card hidden" data-experiment="bernoulli">
                <div class="card-header">
                    <h2 style="color:var(--chart-color-4);">4. Ensayo de Bernoulli (p=0.25)</h2>
                    <p class="description">Proporci칩n de 칠xitos converge a p.</p>
                    <p class="expected-value">Valor esperado: \(E[X]=0.25\)</p>
                </div>
                <div class="chart-container"><canvas id="bernoulliChart" role="img" aria-label="Gr치fico bernoulli"></canvas></div>
                <div class="final-average" id="bernoulliFinalAvg" aria-live="polite"></div>
            </article>
        </section>

        <footer>
            <p><strong>Desarrollado por Matem치tica Santiago Fiore</strong></p>
            <p>Recurso educativo para el estudio de la Ley de los Grandes N칰meros</p>
            <p><a href="https://sites.google.com/view/santiago-fiore/portada" target="_blank" rel="noopener noreferrer">Sitio Web</a></p>
        </footer>
    </div>

    <script>
    (function(){
        // --- Helpers para colores ---
        function getCssVar(name){
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || null;
        }
        // Convierte hex (#rrggbb) a rgba con alpha
        function hexToRgba(hex, alpha = 1){
            if(!hex || typeof hex !== 'string') return `rgba(0,0,0,${alpha})`;
            hex = hex.trim().replace('#','');
            // Validar que solo contenga caracteres hexadecimales
            if(!/^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$/.test(hex)) return `rgba(0,0,0,${alpha})`;
            if(hex.length === 3) hex = hex.split('').map(ch=>ch+ch).join('');
            const r = parseInt(hex.substring(0,2),16);
            const g = parseInt(hex.substring(2,4),16);
            const b = parseInt(hex.substring(4,6),16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        // Si la variable css es un color s칩lido (hex o rgb), retorna rgba opcional
        function cssVarToRgba(varName, alpha = 1){
            const val = getCssVar(varName);
            if(!val) return `rgba(0,0,0,${alpha})`;
            const trimmed = val.trim();
            
            // si ya es rgba
            if(trimmed.startsWith('rgba')){
                return alpha === 1 ? trimmed : trimmed.replace(/[\d\.]+\s*\)\s*$/, `${alpha})`);
            }
            // si es rgb
            if(trimmed.startsWith('rgb')){
                const match = trimmed.match(/rgb\s*\(\s*([^)]+)\s*\)/);
                if(match){
                    const values = match[1].trim();
                    return `rgba(${values}, ${alpha})`;
                }
            }
            // si es hex (#...)
            if(trimmed.startsWith('#')) return hexToRgba(trimmed, alpha);
            // fallback
            return `rgba(0,0,0,${alpha})`;
        }

        // --- DOM elements ---
        const numTrialsInput = document.getElementById('numTrials');
        const simulateBtn = document.getElementById('simulateBtn');
        const toggleExpected = document.getElementById('toggleExpected');
        const experimentBtns = document.querySelectorAll('.experiment-btn');
        const experimentCards = document.querySelectorAll('.card[data-experiment]');

        const charts = {};
        const colorCache = {}; // Cach칠 de colores para evitar rec치lculos
        let currentExperiment = 'coin'; // Experimento activo por defecto

        // Manejar selecci칩n de experimentos
        experimentBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const experiment = btn.getAttribute('data-experiment');
                if(experiment === currentExperiment) return;
                
                // Actualizar botones
                experimentBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Actualizar cards (ocultar todos, mostrar solo el activo)
                experimentCards.forEach(card => {
                    if(card.getAttribute('data-experiment') === experiment){
                        card.classList.remove('hidden');
                    } else {
                        card.classList.add('hidden');
                    }
                });
                
                currentExperiment = experiment;
                
                // Ejecutar simulaci칩n del nuevo experimento
                runSimulation();
            });
        });

        // Validaci칩n del campo num칠rico
        numTrialsInput.addEventListener('blur', () => {
            let val = parseInt(numTrialsInput.value, 10);
            const min = parseInt(numTrialsInput.min, 10);
            const max = parseInt(numTrialsInput.max, 10);
            
            if(isNaN(val) || val < min) val = min;
            if(val > max) val = max;
            
            numTrialsInput.value = val;
        });

        simulateBtn.addEventListener('click', runSimulation);
        toggleExpected.addEventListener('change', toggleExpectedValueVisibility);

        // Chart.js defaults: usar colores computados (no variables literales)
        Chart.defaults.font.family = getCssVar('--font-family') || "'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial";
        Chart.defaults.color = getCssVar('--text-muted-color') || '#6c757d';

        // --- Simulaci칩n optimizada con muestreo al vuelo ---
        // Esta versi칩n muestrea mientras calcula, reduciendo memoria de O(n) a O(MAX_POINTS)
        // Ideal para n grandes (ej: 1,000,000) donde guardar todos los puntos ser칤a ineficiente
        function generateSimulationData(n, sampleFunction, maxPoints = 2000){
            if(!Number.isInteger(n) || n <= 0) throw new Error('n debe ser un entero positivo');
            
            // Si n es peque침o, guardamos todos los puntos
            if(n <= maxPoints){
                const data = new Array(n);
                let accumulator = 0;
                for(let i = 1; i <= n; i++){
                    accumulator += sampleFunction();
                    data[i-1] = accumulator / i;
                }
                return { data, labels: data.map((_, i) => i + 1) };
            }
            
            // Para n grande: muestreo estratificado al vuelo
            const sampledData = [];
            const sampledLabels = [];
            const step = Math.floor(n / maxPoints);
            
            let accumulator = 0;
            let nextSamplePoint = step;
            
            for(let i = 1; i <= n; i++){
                accumulator += sampleFunction();
                
                // Guardamos el punto si:
                // 1. Es un m칰ltiplo del paso de muestreo
                // 2. Es el 칰ltimo punto (crucial para ver la convergencia final)
                if(i === nextSamplePoint || i === n){
                    sampledData.push(accumulator / i);
                    sampledLabels.push(i);
                    nextSamplePoint += step;
                }
            }
            
            return { data: sampledData, labels: sampledLabels };
        }
        
        // Nota sobre Math.random():
        // Usamos el generador pseudoaleatorio del navegador (implementaci칩n espec칤fica de cada motor JS).
        // Para prop칩sitos educativos es m치s que suficiente. En simulaciones de Monte Carlo profesionales
        // se usar칤an generadores como Mersenne Twister, pero para la LGN esto es adecuado.
        // Nota t칠cnica: Para aplicaciones criptogr치ficas o distribuciones hiper-uniformes se usar칤a
        // crypto.getRandomValues(), aunque es m치s lento y aqu칤 no necesario.
        
        // --- Simulaciones espec칤ficas ---
        function simulateCoinFlips(n){
            return generateSimulationData(n, () => Math.random() < 0.5 ? 1 : 0);
        }
        function simulateDiceRolls(n){
            return generateSimulationData(n, () => Math.floor(Math.random() * 6) + 1);
        }
        function simulateUniform(n){
            return generateSimulationData(n, () => Math.random());
        }
        function simulateBernoulli(n, p = 0.25){
            if(p < 0 || p > 1) throw new Error('p debe estar entre 0 y 1');
            return generateSimulationData(n, () => Math.random() < p ? 1 : 0);
        }

        // Funci칩n auxiliar para obtener colores con cach칠
        function getCachedColor(varName, alpha = 1){
            const cacheKey = `${varName}_${alpha}`;
            if(!colorCache[cacheKey]){
                colorCache[cacheKey] = cssVarToRgba(varName, alpha);
            }
            return colorCache[cacheKey];
        }

        // Renderizado de gr치fico optimizado
        function renderChart(canvasId, result, expectedValue, cssVarColorName, finalAvgId, xAxisLabel, yAxisLabel){
            const canvas = document.getElementById(canvasId);
            if(!canvas) return;
            
            // Validaciones
            if(!result || !Array.isArray(result.data) || result.data.length === 0) {
                document.getElementById(finalAvgId).innerHTML = 'Sin datos';
                return;
            }

            const { data, labels } = result;
            
            // Obtener colores (con cach칠)
            const lineColor = getCachedColor(cssVarColorName, 1);
            const fillColor = getCachedColor(cssVarColorName, 0.12);
            const expectedColor = getCachedColor('--expected-value-color', 1);

            // Datos para los datasets
            // Convertir a formato {x, y} para compatibilidad con eje linear
            const dataPoints = data.map((y, i) => ({x: labels[i], y: y}));
            
            const chartData = {
                datasets: [
                    {
                        label: 'Promedio emp칤rico',
                        data: dataPoints,
                        borderColor: lineColor,
                        backgroundColor: fillColor,
                        borderWidth: 2,
                        pointRadius: 0,
                        tension: 0.2,
                        fill: false
                    },
                    {
                        label: 'Valor esperado te칩rico',
                        // Optimizaci칩n: solo 2 puntos necesarios para una l칤nea recta horizontal
                        data: [{x: labels[0], y: expectedValue}, {x: labels[labels.length - 1], y: expectedValue}],
                        borderColor: expectedColor,
                        borderWidth: 2.5,
                        borderDash: [6,6],
                        pointRadius: 0,
                        fill: false,
                        hidden: !toggleExpected.checked
                    }
                ]
            };

            // Si el chart ya existe, actualizamos los datos (m치s eficiente que destruir)
            if(charts[canvasId]){
                try {
                    charts[canvasId].data = chartData;
                    charts[canvasId].update('none'); // 'none' = sin animaci칩n para mejor performance
                } catch(e){
                    console.warn(`Error al actualizar chart ${canvasId}:`, e);
                    // Si falla el update, destruir y recrear
                    charts[canvasId].destroy();
                    charts[canvasId] = null;
                }
            }
            
            // Crear nuevo chart si no existe
            if(!charts[canvasId]){
                const ctx = canvas.getContext('2d');
                charts[canvasId] = new Chart(ctx, {
                    type: 'line',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        animation: { duration: 0 },
                        scales: {
                            x: { 
                                type: 'linear',
                                title: { display: true, text: xAxisLabel, font: { size: 13 } } 
                            },
                            y: { title: { display: true, text: yAxisLabel, font: { size: 13 } } }
                        },
                        plugins: {
                            tooltip: { mode: 'index', intersect: false },
                            legend: { position: 'top', labels: { usePointStyle: true } }
                        },
                        interaction: { mode: 'nearest', axis: 'x', intersect: false }
                    }
                });
            }

            // Promedio final (usar el 칰ltimo valor real)
            const finalValue = data[data.length - 1];
            document.getElementById(finalAvgId).innerHTML = `Promedio final: <span style="color:${lineColor}">${Number(finalValue).toFixed(4)}</span>`;
        }

        function toggleExpectedValueVisibility(){
            const visible = toggleExpected.checked;
            for(const id in charts){
                if(!charts[id]) continue;
                if(charts[id].data && charts[id].data.datasets && charts[id].data.datasets[1]){
                    charts[id].data.datasets[1].hidden = !visible;
                    charts[id].update();
                }
            }
        }

        function runSimulation(){
            // Validaci칩n robusta de entrada
            const n = parseInt(numTrialsInput.value, 10);
            const minTrials = parseInt(numTrialsInput.min, 10);
            const maxTrials = parseInt(numTrialsInput.max, 10);
            
            if(!Number.isInteger(n) || n < minTrials || n > maxTrials){
                alert(`El n칰mero de simulaciones debe estar entre ${minTrials} y ${maxTrials}.`);
                numTrialsInput.value = Math.min(Math.max(n || minTrials, minTrials), maxTrials);
                return;
            }

            simulateBtn.disabled = true;
            simulateBtn.innerHTML = 'Simulando... <span class="spinner" aria-hidden="true"></span>';

            // Usar requestAnimationFrame para mejor rendimiento
            requestAnimationFrame(() => {
                setTimeout(() => {
                    try{
                        // Ejecutar solo la simulaci칩n del experimento activo (performance optimizada)
                        switch(currentExperiment){
                            case 'coin':
                                renderChart('coinChart', simulateCoinFlips(n), 0.5, '--chart-color-1', 'coinFinalAvg', 'N칰mero de lanzamientos', 'Proporci칩n de caras');
                                break;
                            case 'dice':
                                renderChart('diceChart', simulateDiceRolls(n), 3.5, '--chart-color-2', 'diceFinalAvg', 'N칰mero de lanzamientos', 'Promedio del resultado');
                                break;
                            case 'uniform':
                                renderChart('uniformChart', simulateUniform(n), 0.5, '--chart-color-3', 'uniformFinalAvg', 'N칰mero de muestras', 'Promedio de la muestra');
                                break;
                            case 'bernoulli':
                                renderChart('bernoulliChart', simulateBernoulli(n, 0.25), 0.25, '--chart-color-4', 'bernoulliFinalAvg', 'N칰mero de ensayos', 'Proporci칩n de 칠xitos');
                                break;
                        }
                    } catch(err){
                        console.error('Error durante simulaci칩n:', err);
                        const errorMsg = err.message || 'Error desconocido';
                        alert(`Error durante la simulaci칩n: ${errorMsg}. Verifica la consola para m치s detalles.`);
                    } finally {
                        simulateBtn.disabled = false;
                        simulateBtn.innerHTML = 'Lanzar Simulaci칩n';
                    }
                }, 10);
            });
        }

        // correr al iniciar (solo el experimento activo)
        runSimulation();
    })();
    </script>
</body>
</html>
